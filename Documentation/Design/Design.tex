\documentclass[12pt]{article}

\setcounter{secnumdepth}{5}

\usepackage[margin=1in]{geometry}
\usepackage{setspace}
\onehalfspacing

\usepackage{floatrow}

\usepackage{multirow}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{array}
\usepackage{graphicx}

\begin{document}

\title{n8 Game Framework Design Document}
\author{Nate Ebel}

\maketitle

\tableofcontents
\pagebreak

\section{Current Ideas and Things to Think About}
\begin{itemize}
	\item Using a more ``pure'' entity-component system with systems operating on components and the ``entity'' or game object just acts as an id to relate components loosely to one another
	\item Systems can be treated as services that are globally available through a service locator
	\item \dots more ideas and full new design for ECS in notes
\end{itemize}

\section{Design and Use Patterns}
\subsection{Command}
\subsection{Observer}
\subsection{Subclass Sandbox}
\subsection{Singleton}
\subsection{Service Locator}
\subsection{Components}

\section{Client Use/Interaction}
Client should instantiate a single instance of a Game object.  

\section{	Engine Core}
\subsection{Game Loop}
Takes place within Game and uses the Game object's GameTimer instance to control the loop.  Within the loop the current GameState is processed at each iteration.

\subsection{Window Management}
Should be a window object.  Should support renaming and resizing.

\subsection{Resource Management}
		
\subsection{	State Management}
	
\section{	Game States}
A GameState is whatever is happening in the forefront of the game.  GameStates will be maintained on a stack within a GameStateManger.  GameStateManager acts as a bridge between the game loop within Game and the currently active GameState.  Should support passing of entities between states, and each GameState will maintain a list of its entities.  GameStates will include 3 key methods of responding to user input, updating, and rendering.  The Update method will receive the current time as an argument, and Render will receive the current window canvas as an argument.  These 3 methods will be called in the game loop within the Game object.  Pause and resume methods can be overridden to handle changes to and from the GameState.

%\section{ Entity-Component System}
%\subsection{	Entities }
%Entities will be constructed using an entity-component system.  Entity will be a general class that can store different components.  Different behaviors will then come from which components an entity has.  Entity will have a broadcast method to send messages between components.
%\subsection{	Components }
%Functionality can be added to entities through components.  A component could be a position, a sprite, player information, or anything else that helps differentiate an entity or added to an entity's behavior.  Components should take a GameObject pointer as an argument to its methods so s single instance of a component could potentially be used for many entities if the component is stateless.
%\subsubsection{ Component Communication }
%\paragraph{ Shared State}
%Entity data that is cross-domain and will be used be multiple components should just be maintained in the entity class.  This is a good candidate for data such as x and y position.
%\paragraph{ Direct Reference }
%Components that are closely related could store direct references to one another.  For now, this approach is not supported.
%\paragraph{ Messaging }
%Components can broadcast and receive messages to one another.  A component can then be wired to handle a particular message type.  For example, physics component could detect and collision and broadcast a collision event which the audio component handles by playing a sound and the player info component handles be decreasing the player's health.  These messages could be as simple as an int or they could be a message object containing more information.

\section{Entity-Component System}
The entity-component system will be the core of gameplay, logic, and game customization.  

\subsection{Entities (GameObjects)}
An object visible within the game's screen will be an entity of GameObject.  These could include a chest, a power up, or a user controller character.  GameObjects should simply act as a common identifier with which to relate separate components.  The behavior and attributes of a GameObject will depend solely on which components are related to the GameObject.  For example, the difference between a stationary enemy and one that moves around could be the additional of a ``movement'' component that updates the enemy's position frequently.  GameObjects will be created and stored by a GameObjectFactory that will be customized by the client to produced the desired object types.  GameObjects will maintain a list of handles for their associated components.  

To maintain the life of a GameObject when a State goes out of focus, the client can simply not unregister that GameObject ID when the state goes out of focus.  

\subsection{	Components}
A component will contain the data needed to provide some specific functionality to a GameObject.  Every game object will have a ``Location'' component to track where the object is and its size.  Components will not contain methods, and instead will be operated on by ``Systems''.  These systems will store the components they operate on. 

\subsection{	Systems} 
A system provides behavior for, and operates on components.  They are responsible for updating components during each iteration of the game loop.  A system will store each object that it operates on so they are together in memory when System.Update() is called.  Components in the system will be referenced by their handle.  When a component is removed from a system, a member variable counting the current components will be decremented, and a placeholder object inserted so other components' handles aren't affected.  When a new component is created, if the size of the vector and the count of components aren't the same, the new component will be inserted at the empty position.  

Systems will be able to communicate with one another by broadcasting messages to a SystemManager which will route message to registered systems.

\subsection{	Input }
Input will be handled by an InputSystem that tracks which keys have been pressed down or are up.  These states will be able to hold pointers to Command objects that define an action to take.  Game states can then register which commands are associated with which inputs when the state gains focus.
 

\subsection{	Rendering }
\subsubsection{Rendering operations }
	\begin{itemize}
		\item Render single entity
		\item Render single entity with a camera object (Camera: see Section \ref{sec:Camera})
	\end{itemize}

\subsubsection{ Camera} \label{sec:Camera}
A camera object can be passed in to an entity's render method to have it draw based on the camera's current position.

\subsubsection{Static sprite }
\subsubsection{Animated sprite }
\subsection{	Physics}
\subsection{	Game Logic}
\subsection{	AI}
\subsection{	UI}
\subsection{	Audio}
\subsection{	ObjectFactory}


\section{	Events }
Events/messages between components are handled by broadcasting messages to other components.  Events/messages between an entity/component and a higher level system such as GUI or achievement system will use the observer pattern. 

\section{	Game levels}

\section{ Globally Available Services}
Use globally available service locator.  The service locator should support registering and unregistering of services, and retrieval of those services.  Ensuring that a service is available before be used will be the job of client code.

\subsection{ Logging }
Logging should be available to any aspect of the system through the ServiceLocator.    

\section{	System wide values and enums}

\section{	Configuration data/files}

\section{Use Cases}
\subsection{Input changes game state}
\subsection{Input changes player state}
walking $\rightarrow$ flying
\subsection{Input moves player}
\subsection{Entity destroyed and animation is played}
\subsection{Timed event activated}
\subsection{Timed event destroyed}
\subsection{Entity collision}
\subsection{AI player must make a decision}
\subsection{Notify an achievement system when 5 enemies are destroyed}
\subsection{Remap an action's key}




\end{document}
