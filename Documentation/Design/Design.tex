\documentclass[12pt]{article}

\setcounter{secnumdepth}{5}

\usepackage[margin=1in]{geometry}
\usepackage{setspace}
\onehalfspacing

\usepackage{floatrow}

\usepackage{multirow}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{array}
\usepackage{graphicx}

\begin{document}

\title{n8 Game Framework Design Document}
\author{Nate Ebel}

\maketitle

\tableofcontents
\pagebreak

\section{Design and Use Patterns}
\subsection{Command}
\subsection{Observer}
\subsection{Subclass Sandbox}
\subsection{Singleton}
\subsection{Service Locator}
\subsection{Components}

\section{Client Use/Interaction}
Client should instantiate a single instance of a Game object.  

\section{Resource Management}

\section{Game Loop}
Takes place within Game and uses the Game object's GameTimer instance to control the loop.  Within the loop the current GameState is processed at each iteration.
		
\section{Window Management}
Should be a window object.  This object should be stored by the Game class.  Should support renaming and resizing.  
	
\section{	Game States}
A GameState is whatever is happening in the forefront of the game.  GameStates will be maintained on a stack within a GameStateManger.  GameStateManager acts as a bridge between the game loop within Game and the currently active GameState.  Should support passing of entities between states, and each GameState will maintain a list of its entities.  GameStates will include 3 key methods of responding to user input, updating, and rendering.  The Update method will receive the current time as an argument, and Render will receive the current window canvas as an argument.  These 3 methods will be called in the game loop within the Game object.  Pause and resume methods can be overridden to handle changes to and from the GameState.

\section{ Entity-Component System}
\subsection{	Entities }
Entities will be constructed using an entity-component system.  Entity will be a general class that can store different components.  Different behaviors will then come from which components an entity has.  Entity will have a broadcast method to send messages between components.
\subsection{	Components }
Functionality can be added to entities through components.  A component could be a position, a sprite, player information, or anything else that helps differentiate an entity or added to an entity's behavior.  Components should take a GameObject pointer as an argument to its methods so s single instance of a component could potentially be used for many entities if the component is stateless.
\subsubsection{ Component Communication }
\paragraph{ Shared State}
Entity data that is cross-domain and will be used be multiple components should just be maintained in the entity class.  This is a good candidate for data such as x and y position.
\paragraph{ Direct Reference }
Components that are closely related could store direct references to one another.  For now, this approach is not supported.
\paragraph{ Messaging }
Components can broadcast and receive messages to one another.  A component can then be wired to handle a particular message type.  For example, physics component could detect and collision and broadcast a collision event which the audio component handles by playing a sound and the player info component handles be decreasing the player's health.  These messages could be as simple as an int or they could be a message object containing more information.

\section{	Input }

\section{	Events }
Events/messages between components are handled by broadcasting messages to other components.  Events/messages between an entity/component and a higher level system such as GUI or achievement system will use the observer pattern.  

\section{	Rendering }
\subsection{Rendering operations }
\begin{itemize}
	\item Render single entity
	\item Render single entity with a camera object (Camera: see Section \ref{sec:Camera})
\end{itemize}
\subsection{Static sprite }
\subsection{Animated sprite }


\section{ Camera} \label{sec:Camera}

\section{	Operations on or using entities}
		AI
		physics

\section{	Game levels}

\section{ Globally Available Services}
Use globally available service locator.  The service locator should support:
\begin{itemize}
	\item registering and unregistering of services
	\item should be initialized at start.  This is when service objects will be provided to the locator
\end{itemize}

\subsection{ Logging }
Logging should be available to any aspect of the system. 
\subsection{ Audio Player} 

\section{	System wide values and enums}

\section{	Configuration data/files}

\section{Use Cases}
\subsection{Input changes game state}
\subsection{Input changes player state}
walking $\rightarrow$ flying
\subsection{Input moves player}
\subsection{Entity destroyed and animation is played}
\subsection{Timed event activated}
\subsection{Timed event destroyed}
\subsection{Entity collision}
\subsection{AI player must make a decision}
\subsection{Notify an achievement system when 5 enemies are destroyed}
\subsection{Remap an action's key}




\end{document}
