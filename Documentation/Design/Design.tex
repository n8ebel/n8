\documentclass[12pt]{article}

\setcounter{secnumdepth}{5}

\usepackage[margin=1in]{geometry}
\usepackage{setspace}
\onehalfspacing

\usepackage{floatrow}

\usepackage{multirow}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{array}
\usepackage{graphicx}

\begin{document}

\title{n8 Game Framework Design Document}
\author{Nate Ebel}

\maketitle

\tableofcontents
\pagebreak

\section{Current Ideas and Things to Think About}
\begin{itemize}
	\item Using a more ``pure'' entity-component system with systems operating on components and the ``entity'' or game object just acts as an id to relate components loosely to one another
	\item Systems can be treated as services that are globally available through a service locator
	\item \dots more ideas and full new design for ECS in notes
\end{itemize}

\section{Design and Use Patterns}
\subsection{Command}
\subsection{Observer}
\subsection{Subclass Sandbox}
\subsection{Singleton}
\subsection{Service Locator}
\subsection{Components}

\section{Client Use/Interaction}
Client should instantiate a single instance of a Game object.  

\section{	Engine Core}
\subsection{Game Loop}
Takes place within Game and uses the Game object's GameTimer instance to control the loop.  Within the loop the current GameState is processed at each iteration.

\subsection{Window Management}
Should be a window object.  Should support renaming and resizing.

\subsection{Resource Management}
		
\subsection{	State Management}
	
\section{	Game States}
A GameState is whatever is happening in the forefront of the game.  GameStates will be maintained on a stack within a GameStateManger.  GameStateManager acts as a bridge between the game loop within Game and the currently active GameState.  Should support passing of entities between states, and each GameState will maintain a list of its entities.  GameStates will include 3 key methods of responding to user input, updating, and rendering.  The Update method will receive the current time as an argument, and Render will receive the current window canvas as an argument.  These 3 methods will be called in the game loop within the Game object.  Pause and resume methods can be overridden to handle changes to and from the GameState.

%\section{ Entity-Component System}
%\subsection{	Entities }
%Entities will be constructed using an entity-component system.  Entity will be a general class that can store different components.  Different behaviors will then come from which components an entity has.  Entity will have a broadcast method to send messages between components.
%\subsection{	Components }
%Functionality can be added to entities through components.  A component could be a position, a sprite, player information, or anything else that helps differentiate an entity or added to an entity's behavior.  Components should take a GameObject pointer as an argument to its methods so s single instance of a component could potentially be used for many entities if the component is stateless.
%\subsubsection{ Component Communication }
%\paragraph{ Shared State}
%Entity data that is cross-domain and will be used be multiple components should just be maintained in the entity class.  This is a good candidate for data such as x and y position.
%\paragraph{ Direct Reference }
%Components that are closely related could store direct references to one another.  For now, this approach is not supported.
%\paragraph{ Messaging }
%Components can broadcast and receive messages to one another.  A component can then be wired to handle a particular message type.  For example, physics component could detect and collision and broadcast a collision event which the audio component handles by playing a sound and the player info component handles be decreasing the player's health.  These messages could be as simple as an int or they could be a message object containing more information.

\section{Entity-Component System}
The entity-component system will be the core of gameplay, logic, and game customization.  

\subsection{Entities (GameObjects)}
An object visible within the game's screen will be an entity of GameObject.  These could include a chest, a power up, or a user controller character.  GameObjects should act as a common identifier between components, and as the central storage location for each component.  The behavior and attributes of a GameObject will depend solely on which components are related to the GameObject.  For example, the difference between a stationary enemy and one that moves around could be the additional of a ``movement'' component that updates the enemy's position frequently.  GameObjects will be created and stored by a GameObjectFactory that will be customized by the client to produced the desired object types.  When the GameObjectFactory creates an object, it will register it with the necessary Systems.  GameObjects will maintain a list of their associated components.  Pointers to these components will be stored by Systems in order to do batch component processing.    

\subsection{	Components}
A component will contain the data needed to provide some specific functionality to a GameObject.  Every game object will have a ``Location'' component to track where the object is and its size.  Components will not contain methods, and instead will be operated on by ``Systems''.  These systems will store pointers to the components they operate on.  When an entity is registered with a System, if the entity possesses the required component a pointer to that component will be stored in the system to enable batch processing. 

\subsection{	Systems} 
A system provides behavior for, and operates on components.  They are responsible for updating components during each iteration of the game loop.  A system will store each object that it operates on so they are together in memory when System.Update() is called.  When a component is removed from a system, a member variable counting the current components will be decremented, and a placeholder object inserted so other components' handles aren't affected.  When a new component is created, if the size of the vector and the count of components aren't the same, the new component will be inserted at the empty position.  

Systems will be able to communicate with one another using the Observer pattern.  During engine setup, default systems that need to communicate will be registered as observable and subject objects.  Game specific systems can register to observe other systems when they are created at game startup.

\subsection{	Input }
Input will be handled by an InputSystem that tracks which keys have been pressed down or are up.  These states will be able to hold pointers to Command objects that define an action to take.  Game states can then register which commands are associated with which inputs when the state gains focus.
 

\subsection{	Rendering }
\subsubsection{Rendering operations }
	\begin{itemize}
		\item Render single entity
		\item Render single entity with a camera object (Camera: see Section \ref{sec:Camera})
	\end{itemize}

\subsubsection{ Camera} \label{sec:Camera}
A camera object can be passed in to an entity's render method to have it draw based on the camera's current position.

\subsubsection{Static sprite }
\subsubsection{Animated sprite }
\subsection{	Physics}
\subsection{	Game Logic}
\subsection{	AI}
\subsection{	UI}
\subsection{	Audio}
\subsection{	ObjectFactory}


\section{	Events }
Events/messages between components are handled by broadcasting messages to other components.  Events/messages between an entity/component and a higher level system such as GUI or achievement system will use the observer pattern. 

\section{	Game levels}

\section{ Globally Available Services}
Use globally available service locator.  The service locator should support registering and unregistering of services, and retrieval of those services.  Ensuring that a service is available before be used will be the job of client code.

\subsection{ Logging }
Logging should be available to any aspect of the system through the ServiceLocator.    

\section{	System wide values and enums}

\section{	Configuration data/files}

\section{Use Cases}
\subsection{Input changes game state}
\subsection{Input changes player state}
walking $\rightarrow$ flying
\subsection{Input moves player}
\subsection{Entity destroyed and animation is played}
\subsection{Timed event activated}
\subsection{Timed event destroyed}
\subsection{Entity collision}
\subsection{AI player must make a decision}
\subsection{Notify an achievement system when 5 enemies are destroyed}
\subsection{Remap an action's key}




\end{document}
