\documentclass[12pt]{article}

\setcounter{secnumdepth}{5}

\usepackage[margin=1in]{geometry}
\usepackage{setspace}
\onehalfspacing

\usepackage{floatrow}

\usepackage{multirow}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{array}
\usepackage{graphicx}

\begin{document}

\title{n8 Game Framework Design Document}
\author{Nate Ebel}

\maketitle

\tableofcontents
\pagebreak

\section{Design and Use Patterns}
\subsection{Command}
\subsection{Observer}
\subsection{Subclass Sandbox}
\subsection{Singleton}
\subsection{Service Locator}
\subsection{Components}

\section{Client Use/Interaction}
Client should instantiate a single instance of a Game object.  

\section{Resource Management}

\section{Game Loop}
Takes place within Game and uses the Game object's GameTimer instance to control the loop.  Within the loop the current GameState is processed at each iteration.
		
\section{Window Management}
Should be a window object.  This object should be stored by the Game class.  Should support renaming and resizing.  
	
\section{	Game States}
A GameState is whatever is happening in the forefront of the game.  GameStates will be maintained on a stack within a GameStateManger.  GameStateManager acts as a bridge between the game loop within Game and the currently active GameState.  Should support passing of entities between states, and each GameState will maintain a list of its entities.  GameStates will include 3 key methods of responding to user input, updating, and rendering.  The Update method will receive the current time as an argument, and Render will receive the current window canvas as an argument.  These 3 methods will be called in the game loop within the Game object.  Pause and resume methods can be overridden to handle changes to and from the GameState.

\section{ Entity-Component System}
\subsection{	Entities }
Entities will be constructed using an entity-component system.  Entity will be a general class that can store different components.  Different behaviors will then come from which components an entity has.  Entity will have a broadcast method to send messages between components.
\subsection{	Components }
Functionality can be added to entities through components.  A component could be a position, a sprite, player information, or anything else that helps differentiate an entity or added to an entity's behavior.  Components should take a GameObject pointer as an argument to its methods so s single instance of a component could potentially be used for many entities if the component is stateless.
\subsubsection{ Component Communication }
\paragraph{ Shared State}
Entity data that is cross-domain and will be used be multiple components should just be maintained in the entity class.  This is a good candidate for data such as x and y position.
\paragraph{ Direct Reference }
Components that are closely related could store direct references to one another.  For now, this approach is not supported.
\paragraph{ Messaging }
Components can broadcast and receive messages to one another.  A component can then be wired to handle a particular message type.  For example, physics component could detect and collision and broadcast a collision event which the audio component handles by playing a sound and the player info component handles be decreasing the player's health.  These messages could be as simple as an int or they could be a message object containing more information.

\section{	Input }
Input will be handled by an central input manager that tracks which keys have been pressed down or are up.  Game states can then query the input manager and define state specific behaviors for inputs.

\section{	Events }
Events/messages between components are handled by broadcasting messages to other components.  Events/messages between an entity/component and a higher level system such as GUI or achievement system will use the observer pattern.  

\section{	Rendering }
\subsection{Rendering operations }
\begin{itemize}
	\item Render single entity
	\item Render single entity with a camera object (Camera: see Section \ref{sec:Camera})
\end{itemize}
\subsection{Static sprite }
\subsection{Animated sprite }


\section{ Camera} \label{sec:Camera}
Camera can be used to center drawing operations around a specified entity.  This entity will be registered with the camera as an observable object.  When the camera receives a ``position changed'' event from the entity, it will update its position accordingly.  The camera will be created with the height and width of the current game world.  When the world size changes, the camera will need to be updated.  The camera will be stored within a GameState.  A camera object can be passed in to an entity's render method to have it draw based on the camera's current position.

\section{	Operations on or using entities}
		AI
		physics

\section{	Game levels}

\section{ Globally Available Services}
Use globally available service locator.  The service locator should support registering and unregistering of services, and retrieval of those services.  Ensuring that a service is available before be used will be the job of client code.

\subsection{ Logging }
Logging should be available to any aspect of the system through the ServiceLocator.  
\subsection{ Audio Player} 
The audio service should be available to any aspect of the system through the ServiceLocator.  The audio service should maintain a queue of sounds that have been signaled to play.  Sounds should be played on a separate thread.  

\section{	System wide values and enums}

\section{	Configuration data/files}

\section{Use Cases}
\subsection{Input changes game state}
\subsection{Input changes player state}
walking $\rightarrow$ flying
\subsection{Input moves player}
\subsection{Entity destroyed and animation is played}
\subsection{Timed event activated}
\subsection{Timed event destroyed}
\subsection{Entity collision}
\subsection{AI player must make a decision}
\subsection{Notify an achievement system when 5 enemies are destroyed}
\subsection{Remap an action's key}




\end{document}
